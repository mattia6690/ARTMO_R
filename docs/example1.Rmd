---
title: "Get ARTMO Data"
author: "Mattia Rossi"
output:
  html_document:
    toc: true
    toc_float: true
    number_sections: true
date: "`r format(Sys.time(), '%d %B, %Y')`"
---

*This site shows the basic approach for accessing handling and aggregating ARTMO Databases using ARTMO_R*

# Essentials

This part of the code is necessary to set up the working environment. For easier debugging and testing of the various functions  we subdivided them into several scripts.  
* **Essentials**: Loads Packages as well as some crucial functions.  
* **MySQL**: These functions deal with the MySQL back-end. They grant access to the databases and extract overall values such as table names etc.  
* **Binary**: Functions for the Conversion of the MySQL Binary Blob.  
* **Stats**: Functions applied to several tables.This part has been most trick since each of the three approaches (MLA, VI, Inversion) is stored in a unique way containing Binary Blobs, Matlab objects and regular objects.

The first step consists in loading the necessary functions and packages all specified in the following Scripts.

```{r,warning=FALSE,message=FALSE}
source("../R/Essentials.R")
source("../R/Fun_MySQL.R")
source("../R/Fun_Binary.R")
source("../R/Fun_Stats_CF.R")
source("../R/Fun_Stats_MLA.R")
source("../R/Fun_Stats_VIs.R")
source("../R/Fun_Stats_ALL.R")
```

If used in a script don't forget to adjust the sources replacing *../*

# Connect

Afterwards the connection credentials are necessary. Below you can see the standard MySQL credentials as described in the ARTMO manual.

```{r c1}
user      <- "root"
host      <- "localhost"
password  <- "123456"
```

The connection itself can be done in two ways. First to the overall MySQL without specification of a database in order to explore the available databases with `connect.raw`. Each Database is treated in its own and cannot be used together. If you wish to analyze all the databases at the same time you may need an additional for loop. This is discouraged due to the processing time necessary. If you have multiple databases on your MySQL you can briefly test whether the Database is an ARTMO Database with `is.artmodb`.

```{r c2}

con.raw <- connect.raw(user, password, host)
is      <- is.artmodb(con.raw, user, password, host)
print(is)

```

# Select

The same is necessary for the database of interest. This is explicitly done with `connect.db`
```{r c3}

database  <- is[2]
con       <- connect.db(user, password, host, database)
summary(con)
```

Once connected `get.tables.db` helps to explore the tables stored in the MySQL back-end for the specific database. Here all the possible tables are displayed. The ones not containing any information have a count of 0 and will be discontinued in the next steps

```{r, e1}
db.tabs<-get.tables.db(con)
print(db.tabs)
```

# Search and Store

Furthermore the most important part when dealing with MySQL - or basically with any SQL - code is to link the various tables one to the other. Due to the complexity of ARTMO each approach generates numerous tables, comprise several different data types and are linked in a sometimes inconsistent way to each other. Depending on the workflows more than 10 tables have to be recursively liked one to the other. The `getLinks` function resolves tackles this issue and finds the connection between tables

```{r,e2}

dblinks  <- getLinks(con)
print(dblinks)

```

As you can see above each table contains one master ID that allows the link between the databases. Now all the data from each of the table has to be retrieved from the MySQL database. Hereby no information is written to the HD but everything remains in the RAM, so be aware that huge databases may cause **Memory Issues**.

```{r,e3,warnings=FALSE}
dbtabs   <- getTabs(con,dblinks)
print(dbtabs)
```

The data now is nested depending on the Table Type (which approach has been used). The *MyTable* columns contain all data retrieved in the MySQL database stored in lists of tibbles. The function `dplyr::unnest()` allows to reduce their dimensionality and explore in detail the single tables for each of the approaches. If we want to unravel the Table concerning the results of the Database we can use

```{r,warnings=FALSE}
table<-dbtabs %>% filter(Table_Name=="train") %>% select(MyTables) %>% unnest
print(table)
```

# Aggregate

The nesting may has happened on multiple levels in the tibbles. This means that some of the lists contain lists. This level of complexity s necessary to reduce the amount of processing time as well as the RAM resources. The `dbJoin` function helps to aggregate all the information based on the Table_Type column. The *MyTables* column is therefore recursively joined based on the unique identifiers

```{r,warning=FALSE,message=FALSE}
dbjoin   <- doJoin(dbtabs,removeid = T)
print(dbjoin)
```


# Exploration

Actually, this section is up to the next Part of this Website. Nonetheless here is the most common way to analyze one of the Table_Type aggregation. If the `dplyr::unnest` is used on single columns the MySQL result can be analyzed.

**NOTE**: This won't work for the complete tibble since they have different column names. It is recommended to either standardize or process them one by one.

```{r}
statistics<- dbjoin[1,] %>% unnest
print(statistics)
```




